#include "pch.h"

template<class T>
class Array
{
	T* data_;
public:
	
};

/// <summary>
/// ќптимальна€ реалзаци€ по пам€ти
/// </summary>
template<>
class Array<bool>
{
	size_t size_;
	int* data_; // в формате int !!!
public:
	static int const INTBITS = 8 * sizeof(int); // подсчЄт сколько битов влезает в инт = 32
	/// <summary>
	///	 онструктор класса, который принмает кол-во bool, затем выдел€ет пам€ть в виде int !!!
	///	стоит учесть что при выделении пам€ти учитываетьс€ константа и докидываетьс€ 1 инт сверху
	///	так как не всешда удасть€ поделить на цело без остатка, а записать надо все !!!
	/// </summary>
	/// <param name="size"></param>
	explicit Array(size_t size) : size_(size_), data_(new int[size_/ INTBITS + 1])
	{ }
	
	/// <summary>
	/// ¬ажно!!! оператор константный, по этому мы можем вернуть bool по значению. ≈сли оператор не констатный
	/// то нужно вернуть ссылку, но ссылку вернуть нельз€ т.к. ее можно вернуть на те значени€ которые в пам€ти
	/// как то хран€тьс€, в данном случае они €вно в пам€ти Ќ≈ хран€тьс€. Ќельз€ вернуть ссылку на
	/// конкретный бит.
	/// </summary>
	/// <param name="i">ѕор€дковый номер bool. ƒл€ того что бы пон€ть в каком инте он находитьс€ надо разделить
	/// пор€дковый номер на количество бит в инте, а затем ищем бит инта. Ѕерем остаток от делени€ i на кол-во битов в инте.
	/// дл€ выделеи€ нужного бита беретьс€ 1 в битовом представлении и сдвигаетьс€ на необходимое кол-во в лево
	/// после этого мы накладываем эту маску на значение из массива, получим либо все 0 - false
	/// либо много 0 и одну 1  - true</param>
	/// <returns>True или False</returns>
	bool operator[](size_t i) const
	{
		return data_[i / INTBITS] & (1 << (i % INTBITS));
	}
};


template<class T>
void swap(T& a, T & b)
{
	T tmp(a);
	a = b;
	b = tmp;
}

template<class T>
void swap(Array<T> & a, Array<T> & b)
{
	a.swap(b);
}
